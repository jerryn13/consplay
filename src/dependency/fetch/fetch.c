// Subject: Fetch implement of C
// Generated by: ChatGPT
// Prompted by: Jerry Ning
// Created at: 2024.11.9

#include <windows.h>
#include <winhttp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

typedef void (*SSECallback)(const char* chunk);

typedef struct {
    const wchar_t* url;
    const wchar_t* method;
    const char* body;
    const wchar_t* headers; // 自定义 HTTP 请求头
    DWORD timeout;          // 超时时间，单位为毫秒
    int enableSSE;          // 是否启用 SSE
    SSECallback onSSEChunkReceived; // SSE 回调函数
} fetchParams;

typedef struct {
    char* body;
    int status;
    int success;
} fetchResponse;

fetchResponse fetch(const fetchParams* params) {
    fetchResponse response;
    response.body = NULL;
    response.status = 0;
    response.success = 0;

    HINTERNET hSession = WinHttpOpen(L"WinHTTP/1.0",
                                     WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                                     WINHTTP_NO_PROXY_NAME,
                                     WINHTTP_NO_PROXY_BYPASS, 0);
    if (!hSession) {
        return response;
    }

    if (params->timeout > 0) {
        WinHttpSetTimeouts(hSession, params->timeout, params->timeout, params->timeout, params->timeout);
    }

    URL_COMPONENTS urlComponents = {0};
    urlComponents.dwStructSize = sizeof(urlComponents);
    wchar_t hostName[256];
    wchar_t urlPath[256];
    urlComponents.lpszHostName = hostName;
    urlComponents.dwHostNameLength = sizeof(hostName) / sizeof(wchar_t);
    urlComponents.lpszUrlPath = urlPath;
    urlComponents.dwUrlPathLength = sizeof(urlPath) / sizeof(wchar_t);

    if (!WinHttpCrackUrl(params->url, 0, 0, &urlComponents)) {
        WinHttpCloseHandle(hSession);
        return response;
    }

    HINTERNET hConnect = WinHttpConnect(hSession, urlComponents.lpszHostName, urlComponents.nPort, 0);
    if (!hConnect) {
        WinHttpCloseHandle(hSession);
        return response;
    }

    HINTERNET hRequest = WinHttpOpenRequest(hConnect, params->method, urlComponents.lpszUrlPath, NULL,
                                            WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES,
                                            (urlComponents.nPort == INTERNET_DEFAULT_HTTPS_PORT) ? WINHTTP_FLAG_SECURE : 0);
    if (!hRequest) {
        WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hSession);
        return response;
    }

    DWORD bodySize = (params->body != NULL) ? (DWORD)(strlen(params->body) * sizeof(char)) : 0;
    BOOL requestSent = WinHttpSendRequest(hRequest,
                                          params->headers ? params->headers : WINHTTP_NO_ADDITIONAL_HEADERS,
                                          params->headers ? -1L : 0,
                                          (void*)params->body, bodySize,
                                          bodySize, 0);
    if (!requestSent) {
        WinHttpCloseHandle(hRequest);
        WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hSession);
        return response;
    }

    if (!WinHttpReceiveResponse(hRequest, NULL)) {
        WinHttpCloseHandle(hRequest);
        WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hSession);
        return response;
    }

    DWORD statusCode = 0;
    DWORD statusCodeSize = sizeof(statusCode);
    WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,
                        WINHTTP_HEADER_NAME_BY_INDEX, &statusCode, &statusCodeSize, WINHTTP_NO_HEADER_INDEX);
    response.status = statusCode;

    if (params->enableSSE && params->onSSEChunkReceived) {
        char buffer[1024];
        DWORD bytesRead = 0;

        while (WinHttpReadData(hRequest, buffer, sizeof(buffer), &bytesRead) && bytesRead > 0) {
            buffer[bytesRead] = '\0';
            params->onSSEChunkReceived(buffer);
        }

        response.success = (statusCode >= 200 && statusCode < 300);
    } else {
        DWORD bytesRead = 0;
        DWORD bufferSize = 1024;
        char buffer[1024];
        response.body = (char*)malloc(1);
        response.body[0] = '\0';

        while (WinHttpReadData(hRequest, buffer, bufferSize, &bytesRead) && bytesRead > 0) {
            size_t oldLength = strlen(response.body);
            response.body = (char*)realloc(response.body, oldLength + bytesRead + 1);
            strncat(response.body, buffer, bytesRead);
            response.body[oldLength + bytesRead] = '\0';
        }

        response.success = (statusCode >= 200 && statusCode < 300);
    }

    WinHttpCloseHandle(hRequest);
    WinHttpCloseHandle(hConnect);
    WinHttpCloseHandle(hSession);

    return response;
}

void freeFetchResponse(fetchResponse* response) {
    if (response->body) {
        free(response->body);
        response->body = NULL;
    }
}
